<!DOCTYPE html>
<html>

<head>
</head>
<body>
    <h1>Space Dream</h1>
    <p> Move the robot into the space dream avoiding the satellites. If you get hit the robot will be on fire ! The mirror on the left can help you.</p>
    <ul> Controls:  <li>Move the camera orientation with the arrows </li>
					<li>Move the camera position with q(left) d(right) z(zoom in) s(zoom out)</li>
					<li>Move the robot with k(left) and m(right) or o(up) and l(down) i(out) p(in)</li>
    </ul>
    <canvas id="webgl_canvas" width="1500" height="650"></canvas>
    <div id="fps"></div>
    <div id="camera_mat"></div>
    <div id="proj_mat"></div>

    <script src="../gl-matrix-min.js"></script>
    <script language="javascript" type="text/javascript" src="../camera.js"></script>
    <script language="javascript" type="text/javascript" src="functions.js"></script>
    <script language="javascript" type="text/javascript" src="../shaders.js"></script>
    <script language="javascript" type="text/javascript" src="textures.js"></script>
    <script language="javascript" type="text/javascript" src="objects.js"></script>
    <script>
async function main() {
	// Boilerplate code
	const canvas = document.getElementById('webgl_canvas');
	document.body.style.zoom="73%"
	c_width = canvas.width
	c_height = canvas.height
	const gl = canvas.getContext('webgl');
	
	// Enable tests for better rendering
	gl.enable(gl.DEPTH_TEST);
	//gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!
	

//// Shaders sources ////
	//// Shaders Cubemap 
	const source_cubemap_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
	
		varying vec3 v_texcoord;
		
		uniform mat4 M;
		uniform mat4 V;
		uniform mat4 P;
		uniform mat4 itM;  // inverse transpose model!
	
		void main() {
		mat3 Vrotation = mat3(V);
		vec4 frag_coord = vec4(position, 1.0);
		gl_Position = (P*mat4(Vrotation)*frag_coord).xyww;
		v_texcoord = frag_coord.xyz;
		}
	`;

     const source_cubemap_F = `
		precision mediump float;
		varying vec3 v_texcoord;
		// We have a samplerCube this time! not a 2D texture
		uniform samplerCube u_cubemap;
	
		void main() {
		// We sample the cube at the position of the vertices!
		gl_FragColor = textureCube(u_cubemap, v_texcoord);
		}
	`;
	
	//// Shaders Reflection
    const source_reflection_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		
		varying vec3 v_normal;
		varying vec3 v_frag_coord;
		
		uniform mat4 M;
		uniform mat4 itM;  // inverse transpose model!
		uniform mat4 V;
		uniform mat4 P;
	
		void main() {
		vec4 frag_coord = M*vec4(position, 1.0);
		gl_Position = (P*V*frag_coord);
		v_normal = vec3(itM * vec4(normal, 1.0));
		v_frag_coord = frag_coord.xyz;
		}
    `;

    const source_reflection_F = `
		precision mediump float;
	
		varying vec3 v_normal;
		varying vec3 v_frag_coord;
	
		uniform vec3 u_view_dir;
		uniform samplerCube u_cubemap;
	
		void main() {
		
		vec3 I = normalize(v_frag_coord - u_view_dir);
		vec3 R = reflect(I, normalize(v_normal));
		gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
		}
    `;
	
	//// Shaders Refraction
	const source_refraction_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		
		varying vec3 v_normal;
		varying vec3 v_frag_coord;
		
		uniform mat4 M;
		uniform mat4 itM;  // inverse transpose model!
		uniform mat4 V;
		uniform mat4 P;
	
		void main() {
		vec4 frag_coord = M*vec4(position, 1.0);
		gl_Position = (P*V*frag_coord);
		v_normal = vec3(itM * vec4(normal, 1.0));
		v_frag_coord = frag_coord.xyz;
		}
    `;

    const source_refraction_F = `
		precision mediump float;
		varying vec3 v_normal;
		varying vec3 v_frag_coord;
		// We need the camera position to display a reflection/refraction!
		uniform vec3 u_view_dir;
		// This time We need the cubemap to display a reflection/refraction!
		uniform samplerCube u_cubemap;
	
		void main() {
		/*
			Refraction indices:
			Air:      1.0
			Water:    1.33
			Ice:      1.309
			Glass:    1.52
			Diamond:  2.42
		*/
		float ratio = 1.00 / 1.309;
		vec3 I = normalize(v_frag_coord - u_view_dir);
		//refract â€” calculate the refraction direction for an incident vector
		//https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml
		//refract(incident vector,normal vector,ratio of refraction indices)
		vec3 R = refract(I, normalize(v_normal), ratio);
		gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
		}
    `;
	
	//// Shaders Planets
    const source_planet_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		attribute vec3 tangent;
		attribute vec3 bitangent;
	
		varying vec2 v_texcoord;
		varying vec3 v_color;
		varying vec3 v_frag_coord;
		varying mat3 v_TBN;
		
		uniform mat4 M;
		uniform mat4 V;
		uniform mat4 P;
		uniform mat4 itM;  // inverse transpose model!
	
	
		void main() {
		vec4 frag_coord = M*vec4(position, 1.0);
		gl_Position = P*V*frag_coord;
		//coord for the texture
		v_texcoord = texcoord;
		// We can display the normals or bitangent as a color to debug
		v_color = (normal+1.0)/2.0;
		//v_color = (bitangent+1.0)/2.0;
	
		vec3 T = normalize(vec3(M * vec4(tangent, 0.0)));
		vec3 B = normalize(vec3(M * vec4(bitangent, 0.0)));
		vec3 N = normalize(vec3(M * vec4(normal, 0.0)));
		v_TBN = mat3(T,B,N);
	
	
		v_frag_coord = frag_coord.xyz;
		}
    `;

    const source_planet_F = `
		precision mediump float;
		varying vec2 v_texcoord;
		varying vec3 v_color;
		varying vec3 v_frag_coord;
		varying mat3 v_TBN;
		
		uniform sampler2D u_texture;
		uniform sampler2D u_bumpmap;
		uniform vec3 u_light_pos;
	
		void main() {
		// Phong: let's compute the diffuse light for every fragment
		vec3 L = normalize(u_light_pos - v_frag_coord);

		//vec3 get normal from bump map
		vec3 normal = texture2D(u_bumpmap, vec2(v_texcoord.x, 1.0-v_texcoord.y)).rgb;
		normal = normalize(normal*2.0 - 1.0);
		normal = normalize(v_TBN * normal);
	
		float diffusion = max(0.0, dot(normal, L));
		float ambient = 0.12;
		
		vec3 color = vec3(diffusion+ambient);
		gl_FragColor = vec4(color, 1.0) * texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
		
		}
    `;
    
  //// fragment shader for the robot, add the specular light

    const source_robot_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		attribute vec3 tangent;
		attribute vec3 bitangent;
	
		varying vec2 v_texcoord;
		varying vec3 v_color;
		varying vec3 v_frag_coord;
		varying mat3 v_TBN;
		
		uniform mat4 M;
		uniform mat4 V;
		uniform mat4 P;
		uniform mat4 itM;  // inverse transpose model!
	
	
		void main() {
		vec4 frag_coord = M*vec4(position, 1.0);
		gl_Position = P*V*frag_coord;
		//coord for the texture
		v_texcoord = texcoord;
		// We can display the normals or bitangent as a color to debug
		v_color = (normal+1.0)/2.0;
		//v_color = (bitangent+1.0)/2.0;
	
		vec3 T = normalize(vec3(M * vec4(tangent, 0.0)));
		vec3 B = normalize(vec3(M * vec4(bitangent, 0.0)));
		vec3 N = normalize(vec3(M * vec4(normal, 0.0)));
		v_TBN = mat3(T,B,N);
	
	
		v_frag_coord = frag_coord.xyz;
		}
    `;

    const source_robot_F = `
		precision mediump float;
		varying vec2 v_texcoord;
		varying vec3 v_color;
		varying vec3 v_frag_coord;
		varying mat3 v_TBN;
		
		uniform sampler2D u_texture;
		uniform sampler2D u_bumpmap;
    uniform sampler2D u_metal;
		uniform vec3 u_light_pos;
    uniform vec3 u_view_dir;
	
		void main() {
		// Phong: let's compute the light for every fragment
		vec3 L = normalize(u_light_pos - v_frag_coord);

		//vec3 get normal from bump map
		vec3 normal = texture2D(u_bumpmap, vec2(v_texcoord.x, 1.0-v_texcoord.y)).rgb;
		normal = normalize(normal*2.0 - 1.0);
		normal = normalize(v_TBN * normal);

    float metalness = texture2D(u_metal,vec2(v_texcoord.x, 1.0-v_texcoord.y)).r;
	
		float diffusion = max(0.0, dot(normal, L));
		float ambient = 0.12;

    float spec_strength = 8.0 * metalness;
    vec3 view_dir = normalize(u_view_dir - v_frag_coord);
    vec3 reflect_dir = reflect(-L, normal);

    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
    float specular = spec_strength * spec;
		
		vec3 color = vec3(diffusion + ambient +specular);
		gl_FragColor = vec4(color, 1.0) * texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
		//gl_FragColor = vec4(metal,1.0);
		}
    `;
	
	//// Shaders Sun
    const source_sun_V = `
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		attribute vec3 tangent;
		attribute vec3 bitangent;
	
		
		varying vec2 v_texcoord;

		uniform mat4 M;
		uniform mat4 V;
		uniform mat4 P;
	
		void main() {
      vec4 frag_coord = M*vec4(position, 1.0);
      gl_Position = P*V*frag_coord;
      
      v_texcoord = texcoord;
		}
    `;

    const source_sun_F = `
		precision mediump float;
		
		varying vec2 v_texcoord;
	
		uniform vec3 u_light_pos;
		uniform vec3 u_view_dir;
		uniform sampler2D u_texture;
		
		void main() {	
      // light color
      vec3 light_color = vec3(1.0, 1.0, 0.99);
      
      gl_FragColor = vec4(light_color,1.0)* texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));		
		}
    `;

    ////Shaders Particles
    const source_particle_V = `
		attribute vec3 position;
		varying vec4 v_particleColor;
		uniform mat4 P;
		uniform mat4 V;
		uniform mat4 M;
		uniform vec4 color;
		
		void main(){
		v_particleColor = color;
		gl_Position = P*V*M*vec4(position, 1.0);
		}
    `;

    const source_particle_F = `
		precision mediump float;
		varying vec4 v_particleColor;
		
		void main(){
		gl_FragColor = v_particleColor;
		}
    `;

	//// Shaders Mirror
    const source_mirror_V =`
		attribute vec3 position;
		attribute vec2 texcoord;
		attribute vec3 normal;
		attribute vec3 tangent;
		attribute vec3 bitangent;
	
		varying vec2 v_texcoord;
		varying vec3 v_normal;
	
		uniform mat4 M;
		uniform mat4 V;
		uniform mat4 P;
		uniform mat4 itM;
	
	
		void main(){
		gl_Position = P*V*M*vec4(position, 1.0);
	
		v_texcoord = texcoord;
		v_normal = vec3(itM * vec4(normal, 1.0));
		v_normal = normalize(v_normal);
		}
    `;

    const source_mirror_F = `
		precision mediump float;
	
		varying vec2 v_texcoord;
		varying vec3 v_normal;
	
		uniform vec3 n;
	
		uniform sampler2D u_texture;
	
		void main(){
		gl_FragColor = texture2D(u_texture, vec2(v_texcoord.x, v_texcoord.y));
		}
    `;
	
	
//// Making Shaders ////
	//Shader for cubemap
    var shader_cubemap = make_shader(gl, source_cubemap_V, source_cubemap_F);
    
	// Shader for reflection
    var shader_reflection = make_shader(gl, source_reflection_V, source_reflection_F);
	
	//Shader refraction
	  var shader_refraction = make_shader(gl,source_refraction_V,source_refraction_F);
	
  //Shader for the planet
    var shader_planet = make_shader(gl,source_planet_V, source_planet_F);
  
  //Shader for the robot
    var shader_robot = make_shader(gl,source_robot_V, source_robot_F);

  //Shader for the sun
    var shader_sun = make_shader(gl,source_sun_V,source_sun_F);

  //Shader for the particle
    var shader_particle = make_shader(gl,source_particle_V,source_particle_F);

  //Shader for the mirror
    var shader_mirror = make_shader(gl, source_mirror_V, source_mirror_F);

//// Make textures ////
	// Planet
    var bump_map = make_texture(gl,"../textures/Bump_2K.jpg")
    const u_bump_map = gl.getUniformLocation(shader_planet.program, 'u_bumpmap');
    
    var tex_planet = make_texture(gl,"../textures/Diffuse_2K.jpg");
    const u_tex_moon = gl.getUniformLocation(shader_planet.program, 'u_texture');
    

    //Mercury
    var bump_merc = make_texture(gl,"../textures/mercury_Bump_1K.jpg")
    var tex_merc = make_texture(gl,"../textures/mercury_Diffuse_1K.jpg")


	// Sun
    var tex_sun = make_texture(gl,"../textures/sun.jpg");
    const u_tex_sun = gl.getUniformLocation(shader_sun.program, 'u_texture');
	
	// Robot
    //var tex_robot = make_texture(gl,"../textures/metal.jpg");
    var tex_robot = make_texture(gl,"../textures/Sphere_Bot_color_2.jpg");
    var bump_map_robot = make_texture(gl,"../textures/Sphere_Bot_nmap.jpg");
    var metal_robot = make_texture(gl,"../textures/Sphere_Bot_metalness.jpg");
    const u_bump_robot = gl.getUniformLocation(shader_robot.program, 'u_bumpmap');
    const u_tex_robot = gl.getUniformLocation(shader_robot.program, 'u_texture');
    const u_metal_robot = gl.getUniformLocation(shader_robot.program, 'u_metal');
			
//// Make and load objects 
  // Loading from files
    var cube = await load_obj('../objects/cube.obj');
    var bunny = await load_obj('../objects/bunny_small.obj');
	  var planet = await load_obj('../objects/Moon2_2K.obj');
    var mercury = await load_obj('../objects/Mercury_1K.obj');
	  var sphere = await load_obj('../objects/sphere_smooth.obj');
	  var part = await load_obj('../objects/plane.obj');
	  var cube_mesh = await make_object(gl, cube);
	  var mirror = await load_obj('../objects/plane.obj');
    var robot = await load_obj('../objects/bot_hydrau.obj');
     
	// Making objects
	// Reflective bunny
    var bunny_mesh = await make_object(gl, bunny);
	// Planets
    var pl_mesh = await make_object(gl, planet);
    var pl_mesh2 = await make_object(gl, mercury);
	// Sun
    var sun_mesh = await make_object(gl, sphere);
	// Refractive sphere
    var refract_mesh = await make_object(gl, sphere);
	//Object Robot
    var robot_mesh = await make_object(gl, robot);
    // Particle 
    var part_mesh = await make_object(gl, part);
	// Mirror
	  var mirror_mesh = await make_object(gl, mirror);
    var mirror_norm = glMatrix.vec3.fromValues(0.0,1.0,0.0);
    const u_tex_mirror = gl.getUniformLocation(shader_mirror.program,'u_texture');
	
    const u_color = gl.getUniformLocation(shader_particle.program,'color');

	// Bunny hitbox
	  var rel_body = glMatrix.vec3.fromValues(-0.3,-0.3,-0.1);
	  var rel_ears = glMatrix.vec3.fromValues(-1.3,2.5,-0.2);
	  var rel_head = glMatrix.vec3.fromValues(-2.1,1.2,0.5);
    var bunny_hitbox = await makeHitbox(bunny_mesh.model,[rel_body,rel_ears,rel_head], [2.0,1.0,0.9],gl);

  // Robot hitbox  
    var rel_top = glMatrix.vec3.fromValues(0.0,1.5,0.0);
    var rel_xneg = glMatrix.vec3.fromValues(-1.0,0.5,0.0);
    var rel_xpos = glMatrix.vec3.fromValues(1.0,0.5,0.0);
    var rel_zneg = glMatrix.vec3.fromValues(0.0,0.5,-1.0);
    var rel_zpos = glMatrix.vec3.fromValues(0.0,0.5,1.0);
    var robot_hitbox = await makeHitbox(robot_mesh.model,[rel_top,rel_xneg,rel_xpos,rel_zneg,rel_zpos],[1.0,0.5,0.5,0.5,0.5],gl);
        
//// Placing objects ////

    glMatrix.mat4.translate(bunny_mesh.model,bunny_mesh.model,glMatrix.vec3.fromValues(3.5, -2.0, 2.0));
    glMatrix.mat4.translate(pl_mesh.model,pl_mesh.model, glMatrix.vec3.fromValues(-7.0,0.0,-5.0));
    glMatrix.mat4.translate(pl_mesh2.model,pl_mesh2.model, glMatrix.vec3.fromValues(0.0,7.0,0.0));
	  glMatrix.mat4.translate(robot_mesh.model,robot_mesh.model,glMatrix.vec3.fromValues(0.0, 0.0, 0.0));
    glMatrix.mat4.translate(part_mesh.model,part_mesh.model,glMatrix.vec3.fromValues(0.0, 1.0, 0.0));

  //Move the mirror
    glMatrix.mat4.translate(mirror_mesh.model,mirror_mesh.model,glMatrix.vec3.fromValues(15.0, -2.5, 0.0));
    glMatrix.mat4.rotate(mirror_mesh.model,mirror_mesh.model,-1.5708, glMatrix.vec3.fromValues(0.0, 0.0, 1.0));
    glMatrix.mat4.scale(mirror_mesh.model,mirror_mesh.model,glMatrix.vec3.fromValues(4.0,4.0,4.0));
  //get the invert transpose matrix used to determine the norm of the mirror
    var itM = glMatrix.mat4.create();
    itM = glMatrix.mat4.invert(itM, mirror_mesh.model);
    itM = glMatrix.mat4.transpose(itM, itM);

    glMatrix.vec3.transformMat4(mirror_norm,mirror_norm,itM);
    glMatrix.vec3.normalize(mirror_norm,mirror_norm);
    //console.log(mirror_norm);
  //get the position of the mirror
    var mirror_position = glMatrix.vec3.fromValues(mirror_mesh.model[12],
                                                 mirror_mesh.model[13],
                                                 mirror_mesh.model[14],);
	

	glMatrix.mat4.translate(refract_mesh.model,refract_mesh.model,glMatrix.vec3.fromValues(-16.0, -3.0, 0.0));

	// Listeners to move the robot 
	moveObjectKey(document,robot_mesh.model,1.0,["0","1"]);
	moveObjectKey(document, part_mesh.model,1.0,["0","1"]);
	
//// Particles ////
    //Create list of particle
    var particle_list = []
    var nr_part = 1000;
    for (var i = 0; i < nr_part; i = i +1){
    particle_list.push(new Particle(glMatrix.vec3.fromValues(0.0,0.0,0.0),
                          glMatrix.vec3.fromValues(0.0,1.0,0.0),
                          glMatrix.vec3.fromValues(1.0,0.0,0.0),
                          glMatrix.vec4.fromValues(1.0,1.0,1.0,1.0),
                          Math.random()));
    }

//// Colliders	////	
	var colliders =[];
	//colliders.push(pl_mesh.model, pl_mesh2.model,robot_mesh.model,bunny_hitbox,refract_mesh.model);
  colliders.push(pl_mesh.model, pl_mesh2.model,robot_hitbox,bunny_hitbox,refract_mesh.model);
	
//// Light source ////
    // We define a light in space and retrieve its ID in the shader
    const light_pos = glMatrix.vec3.fromValues(-7.0, 0.0, 1.0);
    const u_light_pos = gl.getUniformLocation(shader_planet.program, 'u_light_pos');
    const u_light_pos_sun = gl.getUniformLocation(shader_sun.program, 'u_light_pos');
    const u_light_pos_robot = gl.getUniformLocation(shader_robot.program, 'u_light_pos');
    
    // We need to send the inverse transpose of the model matrix for the model
    //const u_itM_p = gl.getUniformLocation(shader_planet.program, 'itM');

    //Translate position of the sun to coincide with light source position
    sun_mesh.model = glMatrix.mat4.translate(sun_mesh.model, sun_mesh.model, light_pos);

//// Camera ////    
    position = glMatrix.vec3.fromValues(0, 0, -4.0)
    up = glMatrix.vec3.fromValues(0.0, 1.0, 0.0)
    yaw = -90.0
    pitch = 0.0
    var camera = make_camera(canvas, position, up, yaw, pitch)
    var projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0)

    const camMatElem = document.querySelector("#camera_mat");
    const projMatElem = document.querySelector("#proj_mat");
    //camera.show_projection_html(projMatElem, projection);


    // Retrieve the adress of the cubemap texture
    var texCube = make_texture_cubemap(gl, '../textures/cubemaps/lightblue');
    const u_cubemap = gl.getUniformLocation(shader_cubemap.program, 'u_cubemap');
    
    
    // We need to send the camera position to the shader
    const u_view_dir = gl.getUniformLocation(shader_reflection.program, 'u_view_dir');
    const u_view_dir_robot = gl.getUniformLocation(shader_robot.program, 'u_view_dir');

//// Frame Buffer ////
    // Uncomment next part to have the Value of the code given by checkFramebufferStatus
    /*
    console.log("gl.FRAMEBUFFER_COMPLETE :",gl.FRAMEBUFFER_COMPLETE);
    console.log("gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT :",gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT);
    console.log("gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT :",gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT);
    console.log("gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS :", gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS);
    console.log("gl.FRAMEBUFFER_UNSUPPORTED :",gl.FRAMEBUFFER_UNSUPPORTED);
    
    console.log("canvas status:",gl.checkFramebufferStatus(gl.FRAMEBUFFER));
    */
  // Create the framebuffer object (fbo) we will use and bind it to make modification
    var fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);

  //Generate a texture to attach to fbo
  //We use a texture and not a render buffer because we need to acces the information
  //stocked to draw the mirror after
    textureColorebuffer = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, textureColorebuffer);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,c_width,c_height,0,gl.RGBA,gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);
  //Attach the texture
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textureColorebuffer,0);

  //Generate renderbuffer for depth and stencil
  //We use a renderbuffer and not a texture because we don't need to access 
  //the information inside it and it is more efficient than using another texture
    var rbo = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
    gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,c_width,c_height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  //Attach the renderbuffer
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,rbo);
  //Enable depth testing now thta we have a depth buffer
    gl.enable(gl.DEPTH_TEST);

  //The console log can be used to check that the fbo is correctly initialized 
    /*console.log("fbo :",gl.checkFramebufferStatus(gl.FRAMEBUFFER));
    console.log("parameter",gl.getParameter(gl.FRAMEBUFFER_BINDING));
    */
    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
    /*console.log("canvas :",gl.checkFramebufferStatus(gl.FRAMEBUFFER));
    console.log("parameter",gl.getParameter(gl.FRAMEBUFFER_BINDING));
    */

//// Parameters before animate loop ////
    var deltaTime = 0;
	var prev_in_collision = [];
	//rotation angle of planet 1
	var theta1 =0.01;
	//rotation angle of planet 2
	var theta2 =0.01;
  // parameter used to know if the robot is on fire
  var start_fire = 0;
  var fire = false;
			
//// Animate loop ////		
    function animate(time) {
        deltaTime += 0.005;
		camera.update(deltaTime);
		
	//// Preprocessing	////
		// ask what objects are in collision 
		var in_collision = checkCollisions(colliders,1.7, [refract_mesh.model], 1.0);
		// update the hibox if an object needing a hitbox has moved
		updateHitbox(bunny_hitbox,[rel_body,rel_ears,rel_head]);
    updateHitbox(robot_hitbox,[rel_top,rel_xneg,rel_xpos,rel_zneg,rel_zpos]);

		// Clear buffer color
        gl.clearColor(0.2, 0.2, 0.2, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //Clear buffer for the framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.clearColor(1.0, 0.6, 0.6, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
		//Obtain the view matrix neede to draw the reflection
        reflec = camera.get_reflection_matrix(mirror_norm, mirror_position);
		
    //// Draw our scene ////
	
		//// Reflective Bunny ////
        shader_reflection.use();
        bunny_mesh.activate(shader_reflection);
        var unif = shader_reflection.get_uniforms();
		
		// Get M V P
        view = camera.get_view_matrix();
        
        gl.uniformMatrix4fv(unif['model'], false, bunny_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
        
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, bunny_mesh.model);
        itM = glMatrix.mat4.transpose(itM, itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);
        gl.uniform3fv(u_view_dir, camera.get_position());
        
		//Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texCube);
        gl.uniform1i(u_cubemap, 0);

        bunny_mesh.draw();
		
		//Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        bunny_mesh.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		
	
	//// Refraction ////
        shader_refraction.use();
        refract_mesh.activate(shader_refraction);
        var unif = shader_refraction.get_uniforms();
		
		// Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, refract_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
        
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, refract_mesh.model);
        itM = glMatrix.mat4.transpose(itM, itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);
        gl.uniform3fv(u_view_dir, camera.get_position());
        
		//Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texCube);
        gl.uniform1i(u_cubemap, 0);

        refract_mesh.draw();
		
		//Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        refract_mesh.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		

     //// Planets  ////  
        shader_planet.use();
		
		//// Planet 1 ////
        pl_mesh.activate(shader_planet);
        var unif = shader_planet.get_uniforms();
        // Planet Motion 
		if (in_collision.includes(pl_mesh.model)&& prev_in_collision.includes(pl_mesh.model)== false){
			//if first loop round in collision => change rotation direction
			theta1 = -theta1
		}
        satellite_rot(pl_mesh.model,theta1, glMatrix.vec3.fromValues(0.0,1.0,0.0),
                      light_pos,glMatrix.vec3.fromValues(0.0,0.0,0.0),
                      glMatrix.vec3.fromValues(1.0,1.0,1.0))
		
		//Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, pl_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
		
        //send the light pos
        gl.uniform3fv(u_light_pos, light_pos);
		
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, pl_mesh.model);
        itM = glMatrix.mat4.transpose(itM,itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);

		//Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex_planet);
        gl.uniform1i(u_tex_moon,0);
		
		//Bumpmap
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, bump_map);
        gl.uniform1i(u_bump_map,1);

        pl_mesh.draw();
		
		//Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        pl_mesh.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		
		//// Planet 2 ////
        // Planet Motion 
        if (in_collision.includes(pl_mesh2.model)&& prev_in_collision.includes(pl_mesh2.model)== false){
			//if first loop round in collision => change rotation direction
			theta2 = -theta2
		}
        satellite_rot(pl_mesh2.model,theta2, glMatrix.vec3.fromValues(-1.0,1.0,0.0),
                          light_pos,glMatrix.vec3.fromValues(0.0,0.0,0.0),
                          glMatrix.vec3.fromValues(1.0,1.0,1.0))
		
		//Get M V P
        gl.uniformMatrix4fv(unif['model'], false, pl_mesh2.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
		
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, pl_mesh2.model);
        itM = glMatrix.mat4.transpose(itM,itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);

    //Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex_merc);
        gl.uniform1i(u_tex_moon,0);
		
		//Bumpmap
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, bump_merc);
        gl.uniform1i(u_bump_map,1);

		
        pl_mesh2.draw();
		
		//Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        pl_mesh2.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		
		
		//// Robot ////
    shader_robot.use();
		robot_mesh.activate(shader_robot);
    var unif = shader_robot.get_uniforms();
    //robot_mesh.activate(shader_planet);
		//Check if in collision 
		if(in_collision.includes(robot_mesh.model)){
			glMatrix.mat4.translate(robot_mesh.model, robot_mesh.model, glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
			glMatrix.mat4.translate(part_mesh.model, part_mesh.model, glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
			fire = true;
			start_fire = deltaTime;
		};

		//Get M V P
        gl.uniformMatrix4fv(unif['view'], false, view);
		    gl.uniformMatrix4fv(unif['model'], false, robot_mesh.model);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
		
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, robot_mesh.model);
        itM = glMatrix.mat4.transpose(itM,itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);
        gl.uniform3fv(u_view_dir_robot, camera.get_position());
    
    //Send the light pos
        gl.uniform3fv(u_light_pos_robot, light_pos);
        
		//Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex_robot);
        gl.uniform1i(u_tex_robot,0);
		
		//Bumpmap
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, bump_map_robot);
        gl.uniform1i(u_bump_robot,1);

    //Metalness
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, metal_robot);
        gl.uniform1i(u_metal_robot,2);
		
		robot_mesh.draw();
		
		//Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        robot_mesh.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);


        //// Sun ////
        shader_sun.use();
        sun_mesh.activate(shader_sun);

        var unif = shader_sun.get_uniforms();
		
		//Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, sun_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
		
        //send the light pos
        gl.uniform3fv(u_light_pos_sun, light_pos);
		
		//Inverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, sun_mesh.model);
        itM = glMatrix.mat4.transpose(itM,itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);
		
		//Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex_sun);
        gl.uniform1i(u_tex_sun,0);

        sun_mesh.draw();

        //// Draw in fbo
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        sun_mesh.draw();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        
        //// Particle ////
        if (fire === true && deltaTime-start_fire < 0.9){
			//If we should have a fire then update position of all particles
			var new_part = 100;
			var part_added = 0;
			for (i in particle_list){
				var part_bool = particle_list[i].update_part(part_added, new_part);
				if (part_bool){
					part_added = part_added + 1;
				}
			}
			//draw the particle - we use another additive blend mode
      //it gives a glow effect when they are stacked one each other
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			shader_particle.use();
			var unif = shader_particle.get_uniforms();
			gl.uniformMatrix4fv(unif['proj'], false, projection);
			gl.uniformMatrix4fv(unif['view'], false, view);
			part_mesh.activate(shader_particle);
			for (i in particle_list){   
				if(particle_list[i].life > 0.0){
					var model_part = glMatrix.mat4.create()
					
					model_part = glMatrix.mat4.translate(model_part,part_mesh.model,particle_list[i].position);
					model_part = glMatrix.mat4.rotate(model_part, model_part, 1.5,particle_list[i].orientation);
					model_part = glMatrix.mat4.scale(model_part,model_part,glMatrix.vec3.fromValues(particle_list[i].size*10,particle_list[i].size*10,particle_list[i].size*10));
					gl.uniformMatrix4fv(unif['model'], false, model_part);
		
					gl.uniform4fv(u_color, particle_list[i].color);
          //Draw the partcile
					gl.uniformMatrix4fv(unif['view'], false, view);
					part_mesh.draw();
          //Draw in the fbo
					gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
					gl.uniformMatrix4fv(unif['view'], false, reflec);
					part_mesh.draw()
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		
				}
			}
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
      else if (fire === true){
      //if the collision was too long ago then we stop the fire 
			  fire = false;
      } 
         
        //// Mirror ////
        //draw the cube map for the mirror:
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.depthFunc(gl.LEQUAL);

        shader_cubemap.use();
        cube_mesh.activate(shader_cubemap);

        var unif = shader_cubemap.get_uniforms();
		
		//Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, reflec);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
        
        // Texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texCube);
        gl.uniform1i(u_cubemap, 0);
        // camera.show_view_html(camMatElem, camera.get_view_matrix());
        cube_mesh.draw();
		
        // set back the depth function for next frame
        gl.depthFunc(gl.LESS);
        gl.bindFramebuffer(gl.FRAMEBUFFER,null);

        //draw the mirror in the canvas
        shader_mirror.use()
        mirror_mesh.activate(shader_mirror);

        const u_n = gl.getUniformLocation(shader_mirror.program,"n");

        var unif = shader_mirror.get_uniforms();
		
		//Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, mirror_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
		
		//INverse transpose
        var itM = glMatrix.mat4.create();
        itM = glMatrix.mat4.invert(itM, mirror_mesh.model);
        itM = glMatrix.mat4.transpose(itM,itM);
        gl.uniformMatrix4fv(unif['itmodel'],false,itM);

        gl.uniform3fv(u_n,mirror_norm);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textureColorebuffer);
        gl.uniform1i(u_tex_mirror,0);

        mirror_mesh.draw();


        //// CubeMap ////

        //*    // uncomment only one slash "/" to comment the cubemap ;)
        // We draw the cubemap ONLY at the end!
        gl.depthFunc(gl.LEQUAL);

        shader_cubemap.use();
        cube_mesh.activate(shader_cubemap);

        var unif = shader_cubemap.get_uniforms();
		
		//Get M V P
        view = camera.get_view_matrix();
        gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
        gl.uniformMatrix4fv(unif['view'], false, view);
        gl.uniformMatrix4fv(unif['proj'], false, projection);
        
        // Texture 
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texCube);
        gl.uniform1i(u_cubemap, 0);
        //camera.show_view_html(camMatElem, camera.get_view_matrix());
        cube_mesh.draw();

        // set back the depth function for next frame
        gl.depthFunc(gl.LESS);
        //*/
		
		//Update in_collision
		prev_in_collision = in_collision;
        fps(time);
        window.requestAnimationFrame(animate); // While(True) loop!
     }

    var prev = 0
    const fpsElem = document.querySelector("#fps");

    function fps(now) {
        now *= 0.001;
        const deltaTime = now - prev;
        prev = now;
        const fps = 1 / deltaTime;
        fpsElem.textContent = 'FPS: ' + fps.toFixed(1);
        return fps;
    }

    animate(0);
}

main();
    </script>
</body>

</html>
