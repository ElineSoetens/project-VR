<!DOCTYPE html>
<html>

<head>
</head>

<body>
    <h1>Implement a reflective object</h1>
    <p>You will need two shaders, one for the cubemap, one for the object</p>
    <p>Main steps:</p>
    
    <canvas id="webgl_canvas" width="600" height="600"></canvas>
    <div id="fps"></div>
    <div id="camera_mat"></div>
    <div id="proj_mat"></div>

    <script src="../gl-matrix-min.js"></script>
    <script language="javascript" type="text/javascript" src="../camera.js"></script>
    <script language="javascript" type="text/javascript" src="functions.js"></script>
    <script language="javascript" type="text/javascript" src="../shaders.js"></script>
    <script language="javascript" type="text/javascript" src="textures.js"></script>
    <script language="javascript" type="text/javascript" src="objects.js"></script>
    <script>
        async function main() {
            // Boilerplate code
            const canvas = document.getElementById('webgl_canvas');
            c_width = canvas.width
            c_height = canvas.height
            const gl = canvas.getContext('webgl');

            // Enable tests for better rendering
            gl.enable(gl.DEPTH_TEST);
            //gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!

            const sourceV = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;

      varying vec3 v_texcoord;
      
      uniform mat4 M;
      uniform mat4 V;
      uniform mat4 P;
      uniform mat4 itM;  // inverse transpose model!

      void main() {
        // 2) Shader code
        mat3 Vrotation = mat3(V);
        vec4 frag_coord = vec4(position, 1.0);
        gl_Position = (P*mat4(Vrotation)*frag_coord).xyww;
        
        v_texcoord = frag_coord.xyz;
      }
    `;

            const sourceF = `
      precision mediump float;
      varying vec3 v_texcoord;

      // We have a samplerCube this time! not a 2D texture
      uniform samplerCube u_cubemap;

      void main() {
        // 2) Shader code
        // We sample the cube at the position of the vertices!
        gl_FragColor = textureCube(u_cubemap, v_texcoord);
      }
    `;

            const source_reflection_V = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
      
      varying vec3 v_normal;
      varying vec3 v_frag_coord;
      
      uniform mat4 M;
      uniform mat4 itM;  // inverse transpose model!
      uniform mat4 V;
      uniform mat4 P;

      void main() {
        vec4 frag_coord = M*vec4(position, 1.0);
        gl_Position = (P*V*frag_coord);
        v_normal = vec3(itM * vec4(normal, 1.0));
        v_frag_coord = frag_coord.xyz;
      }
    `;

            const source_reflection_F = `
      precision mediump float;

      varying vec3 v_normal;
      varying vec3 v_frag_coord;

      uniform vec3 u_view_dir;
      uniform samplerCube u_cubemap;

      void main() {
        //3) Shader code for the object
        vec3 I = normalize(v_frag_coord - u_view_dir);
        vec3 R = reflect(I, normalize(v_normal));
        gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
      }
    `;
	
	                const source_refraction_V = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
	  
	  varying vec3 v_normal;
      varying vec3 v_frag_coord;
      
      uniform mat4 M;
	  uniform mat4 itM;  // inverse transpose model!
      uniform mat4 V;
      uniform mat4 P;

      void main() {
        //3) Shader code for the object
		vec4 frag_coord = M*vec4(position, 1.0);
        gl_Position = (P*V*frag_coord);
        v_normal = vec3(itM * vec4(normal, 1.0));
        v_frag_coord = frag_coord.xyz;
      }
    `;

            const source_refraction_F = `
      precision mediump float;
	  varying vec3 v_normal;
      varying vec3 v_frag_coord;
      
      // We need the camera position to display a reflection/refraction!
      uniform vec3 u_view_dir;
      // This time We need the cubemap to display a reflection/refraction!
      uniform samplerCube u_cubemap;

      void main() {
        //3) Shader code for the object
		/*
            Refraction indices:
            Air:      1.0
            Water:    1.33
            Ice:      1.309
            Glass:    1.52
            Diamond:  2.42
        */
        float ratio = 1.00 / 1.52;
        vec3 I = normalize(v_frag_coord - u_view_dir);
		//refract â€” calculate the refraction direction for an incident vector
		//https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml
		//refract(incident vector,normal vector,ratio of refraction indices)
        vec3 R = refract(I, normalize(v_normal), ratio);
        gl_FragColor = vec4(textureCube(u_cubemap, R).rgb, 1.0);
      }
    `;

            const source_planet_V = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
      attribute vec3 tangent;
      attribute vec3 bitangent;

      varying vec2 v_texcoord;
      varying vec3 v_color;
      varying vec3 v_normal;
      varying vec3 v_frag_coord;
      varying mat3 v_TBN;
      
      uniform mat4 M;
      uniform mat4 V;
      uniform mat4 P;
      uniform mat4 itM;  // inverse transpose model!


      void main() {
        vec4 frag_coord = M*vec4(position, 1.0);
        gl_Position = P*V*frag_coord;
        //coord for the texture
        v_texcoord = texcoord;
        // We will display the normals as a color
        v_color = (normal+1.0)/2.0;
        //v_color = (bitangent+1.0)/2.0;

        vec3 T = normalize(vec3(M * vec4(tangent, 0.0)));
        vec3 B = normalize(vec3(M * vec4(bitangent, 0.0)));
        vec3 N = normalize(vec3(M * vec4(normal, 0.0)));
        v_TBN = mat3(T,B,N);

        //transfor the normal for the light part
        v_normal = vec3(itM * vec4(normal, 1.0));

        v_frag_coord = frag_coord.xyz;
      }
    `;

            const source_planet_F = `
      precision mediump float;
      varying vec2 v_texcoord;
      varying vec3 v_color;
      varying vec3 v_normal;
      varying vec3 v_frag_coord;
      varying mat3 v_TBN;
      
      uniform sampler2D u_texture;
      uniform sampler2D u_bumpmap;
      uniform vec3 u_light_pos;

      void main() {
        // Phong: let's compute the diffuse light with the interpolated normals
        vec3 L = normalize(u_light_pos - v_frag_coord);

        //vec3 normal = normalize(v_normal);

        //vec3 get normal from bump map
        vec3 normal = texture2D(u_bumpmap, vec2(v_texcoord.x, 1.0-v_texcoord.y)).rgb;
        normal = normalize(normal*2.0 - 1.0);
        normal = normalize(v_TBN * normal);

        float diffusion = max(0.0, dot(normal, L));
        float ambient = 0.12;
        
        vec3 color = vec3(diffusion+ambient);

        //gl_FragColor = vec4(color, 1.0);
        gl_FragColor = vec4(color, 1.0) * texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
        //gl_FragColor = vec4(normalize(v_color), 1.0);
      }
    `;

    const source_sun_V = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
      attribute vec3 tangent;
      attribute vec3 bitangent;

      varying vec3 v_normal;
      varying vec3 v_frag_coord;
      varying vec2 v_texcoord;
      
      uniform mat4 M;
      uniform mat4 itM;  // inverse transpose model!
      uniform mat4 V;
      uniform mat4 P;

      void main() {
        // 2) Shader code
        vec4 frag_coord = M*vec4(position, 1.0);
        gl_Position = P*V*frag_coord;
        
        // Transform correctly the normals!
        v_normal = vec3(itM * vec4(normal, 1.0));
        
        v_frag_coord = frag_coord.xyz;
        v_texcoord = texcoord;
      }
    `;

    const source_sun_F = `
      precision mediump float;
      varying vec3 v_normal;
      varying vec3 v_frag_coord;
      varying vec2 v_texcoord;

      uniform vec3 u_light_pos;
      uniform vec3 u_view_dir;
      uniform sampler2D u_texture;
      

      void main() {
        // 2) Shader code
        vec3 normal = normalize(v_normal);

        // light color
        vec3 light_color = vec3(1.0, 1.0, 0.99);

        // Ambient
        float ambient = 0.1;

        vec3 L = normalize(u_light_pos - v_frag_coord);

        // Diffuse
        float diffusion = max(0.0, dot(v_normal, L));

        // specural
        float spec_strength = 0.8;
        vec3 view_dir = normalize(u_view_dir - v_frag_coord);
        vec3 reflect_dir = reflect(-L, normal);
        float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
        float specular = spec_strength * spec;

        vec3 color = (ambient + specular + diffusion) * light_color;
        //vec3 color = (normal+1.0)/2.0;
        
        //gl_FragColor = vec4(color, 1.0);
        gl_FragColor = vec4(light_color,1.0)* texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
        
      }
    `;

    //Shader for the particle
    const source_particle_V = `
      attribute vec3 position;
      varying vec4 v_particleColor;
      uniform mat4 P;
      uniform mat4 V;
      uniform mat4 M;
      uniform vec4 color;
      void main(){
        v_particleColor = color;
        gl_Position = P*V*M*vec4(position, 1.0);
      }
    `;

    const source_particle_F = `
      precision mediump float;
      varying vec4 v_particleColor;
      void main(){
        gl_FragColor = v_particleColor;
      }
    `;

    const source_mirror_V =`
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
      attribute vec3 tangent;
      attribute vec3 bitangent;

      varying vec2 v_texcoord;
      varying vec3 v_normal;

      uniform mat4 M;
      uniform mat4 V;
      uniform mat4 P;
      uniform mat4 itM;


      void main(){
        gl_Position = P*V*M*vec4(position, 1.0);

        v_texcoord = texcoord;
        v_normal = vec3(itM * vec4(normal, 1.0));
        v_normal = normalize(v_normal);
      }
    `;

    const source_mirror_F = `
      precision mediump float;

      varying vec2 v_texcoord;
      varying vec3 v_normal;

      uniform vec3 n;

      uniform sampler2D u_texture;

      void main(){
        gl_FragColor = texture2D(u_texture, vec2(v_texcoord.x, v_texcoord.y));
        //gl_FragColor = vec4(v_normal,1.0);
        //gl_FragColor = vec4(n,1.0);
      }
    `;

            var shader_cubemap = make_shader(gl, sourceV, sourceF);
            // Shader for reflection
            var shader_reflection = make_shader(gl, source_reflection_V, source_reflection_F);
			
			//Shader refraction
			var shader_refraction = make_shader(gl,source_refraction_V,source_refraction_F);
			
            //Shader for the planet
            var shader_planet = make_shader(gl,source_planet_V, source_planet_F);

            //Shader for the sun
            var shader_sun = make_shader(gl,source_sun_V,source_sun_F);

            //Shader for the particle
            var shader_particle = make_shader(gl,source_particle_V,source_particle_F);

            //Shader for the mirror
            var shader_mirror = make_shader(gl, source_mirror_V, source_mirror_F);

            //texture for the planet, color and cubemap
            
            var bump_map = make_texture(gl,"../textures/Bump_2K.jpg")
            //var bump_map = make_texture(gl,"../textures/brickwall_normal.jpg")
            const u_bump_map = gl.getUniformLocation(shader_planet.program, 'u_bumpmap');

            var tex_planet = make_texture(gl,"../textures/Diffuse_2K.jpg");
            //var tex_planet = make_texture(gl,"../textures/brickwall.jpg");
            const u_tex_moon = gl.getUniformLocation(shader_planet.program, 'u_texture');

            var tex_sun = make_texture(gl,"../textures/sun.jpg");
            const u_tex_sun = gl.getUniformLocation(shader_sun.program, 'u_texture');
			
            var tex_robot = make_texture(gl,"../textures/metal.jpg");
			//const u_tex_robot = gl.getUniformLocation(shader_planet.program, 'u_texture');

            var bump_map_robot = make_texture(gl,"../textures/metal_normal.jpg")
            //const u_bump_map_robot = gl.getUniformLocation(shader_planet.program, 'u_bumpmap');
            
            // 1) Load an object
            // loading the object from a file
            var cube = await load_obj('../objects/cube.obj');
            var cube_mesh = await make_object(gl, cube)
            
            // Object on which we want to represent reflections/refractions:
            var obj = await load_obj('../objects/bunny_small.obj');
            var obj_mesh = await make_object(gl, obj)

            // Object planet
            var planet = await load_obj('../objects/Moon2_2K.obj');
            //var planet = await load_obj('../objects/plane.obj');
            var pl_mesh = await make_object(gl, planet)

            var planet2 = await load_obj('../objects/Moon2_2K.obj');
            //var planet = await load_obj('../objects/plane.obj');
            var pl_mesh2 = await make_object(gl, planet2)

            //Object Sun
            var sun = await load_obj('../objects/sphere_smooth.obj');
            var sun_mesh = await make_object(gl, sun);
			
			//Object Sun
            var refract = await load_obj('../objects/sphere_smooth.obj');
            var refract_mesh = await make_object(gl, refract);
			
		    //Object Robot
            var robot = await load_obj('../objects/sphere_smooth.obj');
            var robot_mesh = await make_object(gl, robot);

            //// Particle ////
            var part = await load_obj('../objects/plane.obj');
            var part_mesh = await make_object(gl, part);

            const u_color = gl.getUniformLocation(shader_particle.program,'color');


            var mirror = await load_obj('../objects/plane.obj');
            var mirror_mesh = await make_object(gl, mirror);
            var mirror_norm = glMatrix.vec3.fromValues(0.0,1.0,0.0);
            const u_tex_mirror = gl.getUniformLocation(shader_mirror.program,'u_texture');
            

            
            

			
			var rel_body = glMatrix.vec3.fromValues(-0.3,-0.3,-0.1);
			var rel_ears = glMatrix.vec3.fromValues(-1.3,2.5,-0.2);
			var rel_head = glMatrix.vec3.fromValues(-2.1,1.2,0.5);
			
            var bunny_hitbox = await makeHitbox(obj_mesh.model,[rel_body,rel_ears,rel_head], [2.0,1.0,0.9],gl);
            console.log("bunny_hitbox=",bunny_hitbox)


            // Let's move them a bit
            //glMatrix.mat4.translate(obj_mesh.model,obj_mesh.model,glMatrix.vec3.fromValues(-0.5, 0.0, 1.0));
            glMatrix.mat4.translate(obj_mesh.model,obj_mesh.model,glMatrix.vec3.fromValues(-0.5, -2.0, 2.0));
            glMatrix.mat4.translate(pl_mesh.model,pl_mesh.model, glMatrix.vec3.fromValues(-7.0,0.0,-5.0));
            //glMatrix.mat4.translate(pl_mesh2.model,pl_mesh2.model, glMatrix.vec3.fromValues(-0.5,6.0,7.0));
			      glMatrix.mat4.translate(robot_mesh.model,robot_mesh.model,glMatrix.vec3.fromValues(0.0, 0.0, 0.0));
            //glMatrix.mat4.rotate(pl_mesh.model,pl_mesh.model,1.5, glMatrix.vec3.fromValues(1.0,0.0,0.0)); 
            glMatrix.mat4.translate(part_mesh.model,part_mesh.model,glMatrix.vec3.fromValues(0.0, 1.0, 0.0));


            //Move the mirror
            glMatrix.mat4.translate(mirror_mesh.model,mirror_mesh.model,glMatrix.vec3.fromValues(6.0, -2.5, 0.0))
            //glMatrix.mat4.rotate(mirror_mesh.model,mirror_mesh.model,1.5708, glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
            
            glMatrix.mat4.rotate(mirror_mesh.model,mirror_mesh.model,-1.5708, glMatrix.vec3.fromValues(0.0, 0.0, 1.0));
            //glMatrix.vec3.rotateZ(mirror_norm,mirror_norm,mirror_position,1.5);

            glMatrix.mat4.scale(mirror_mesh.model,mirror_mesh.model,glMatrix.vec3.fromValues(4.0,4.0,4.0));

            var itM = glMatrix.mat4.create();
            itM = glMatrix.mat4.invert(itM, mirror_mesh.model);
            itM = glMatrix.mat4.transpose(itM, itM);

            glMatrix.vec3.transformMat4(mirror_norm,mirror_norm,itM);
            glMatrix.vec3.normalize(mirror_norm,mirror_norm);
            console.log(mirror_norm);
            var mirror_position = glMatrix.vec3.fromValues(mirror_mesh.model[12],
                                                         mirror_mesh.model[13],
                                                         mirror_mesh.model[14],);
			

			glMatrix.mat4.translate(refract_mesh.model,refract_mesh.model,glMatrix.vec3.fromValues(0.0, -5.0, 0.0));



			//glMatrix.mat4.translate(robot_mesh.model,robot_mesh.model, glMatrix.vec3.fromValues(0.0,0.0,20.0));
			moveObjectKey(document,robot_mesh.model,1.0,["0","1"]);
			moveObjectKey(document, part_mesh.model,1.0,["0","1"]);
      //Create list of particle
      var particle_list = []
      var nr_part = 1000;
      for (var i = 0; i < nr_part; i = i +1){
        particle_list.push(new Particle(glMatrix.vec3.fromValues(0.0,0.0,0.0),
                              glMatrix.vec3.fromValues(0.0,1.0,0.0),
                              glMatrix.vec3.fromValues(1.0,0.0,0.0),
                              glMatrix.vec4.fromValues(1.0,1.0,1.0,1.0),
                              Math.random()));
      }
			
			var colliders =[];
			colliders.push(pl_mesh.model, pl_mesh2.model,robot_mesh.model,bunny_hitbox);
			//console.log("tes=",colliders[3][0].length)

            // We define a light in space and retrieve its ID in the shader
            const light_pos = glMatrix.vec3.fromValues(-7.0, 0.0, 1.0);
            const u_light_pos = gl.getUniformLocation(shader_planet.program, 'u_light_pos');
            const u_light_pos_sun = gl.getUniformLocation(shader_sun.program, 'u_light_pos');
            
            // We need to send the inverse transpose of the model matrix for the model
            //const u_itM_p = gl.getUniformLocation(shader_planet.program, 'itM');

            //Translate position of the sun to coincide with light source position
            sun_mesh.model = glMatrix.mat4.translate(sun_mesh.model, sun_mesh.model, light_pos);
            //sun_mesh.model = glMatrix.mat4.translate(sun_mesh.model, sun_mesh.model, glMatrix.vec3.fromValues(-0.5,0.0,7.0));

            
            position = glMatrix.vec3.fromValues(0, 0, -4.0)
            up = glMatrix.vec3.fromValues(0.0, 1.0, 0.0)
            yaw = -90.0
            pitch = 0.0
            var camera = make_camera(canvas, position, up, yaw, pitch)
            var projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0)

            const camMatElem = document.querySelector("#camera_mat");
            const projMatElem = document.querySelector("#proj_mat");
            camera.show_projection_html(projMatElem, projection);


            // Retrieve the adress of the cubemap texture
            // 5) Code for creating the cubemap
            var texCube = make_texture_cubemap(gl, '../textures/cubemaps/lightblue');
            //var texCube = make_texture_cubemap(gl, '../textures/cubemaps/Yokohama');
            const u_cubemap = gl.getUniformLocation(shader_cubemap.program, 'u_cubemap');
            
            // 4) Define all the variables you will need to perform the computations
            //    in the shaders here! (light, useful matrices, ...)
            // We need to send the inverse transpose of the model matrix for the model
            //const u_itM = gl.getUniformLocation(shader_reflection.program, 'itM');
            
            // We need to send the camera position to the shader
            const u_view_dir = gl.getUniformLocation(shader_reflection.program, 'u_view_dir');

            //// Frame Buffer ////

            //Val of the code :
            console.log("gl.FRAMEBUFFER_COMPLETE :",gl.FRAMEBUFFER_COMPLETE);
            console.log("gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT :",gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT);
            console.log("gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT :",gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT);
            console.log("gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS :", gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS);
            console.log("gl.FRAMEBUFFER_UNSUPPORTED :",gl.FRAMEBUFFER_UNSUPPORTED);

            console.log("canvas status:",gl.checkFramebufferStatus(gl.FRAMEBUFFER));

            var fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);

            //generate texture to attach to fbo
            textureColorebuffer = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, textureColorebuffer);
            gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,c_width,c_height,0,gl.RGBA,gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textureColorebuffer,0);

            //generate renderbuffer for the depth (and stencil ?)
            var rbo = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
            gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,c_width,c_height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,rbo);

            gl.enable(gl.DEPTH_TEST);

            console.log("fbo :",gl.checkFramebufferStatus(gl.FRAMEBUFFER));
            console.log("parameter",gl.getParameter(gl.FRAMEBUFFER_BINDING));

            gl.bindFramebuffer(gl.FRAMEBUFFER,null);
            console.log("canvas :",gl.checkFramebufferStatus(gl.FRAMEBUFFER));
            console.log("parameter",gl.getParameter(gl.FRAMEBUFFER_BINDING));
            
            //gl.deleteFramebuffer(fbo);

            var deltaTime = 0;
			var prev_in_collision = [];
			var theta1 =0.01;
			var theta2 =0.01;
      var start_fire = 0;
      var fire = false;
			
			
			
            function animate(time) {
                deltaTime += 0.005;

				var in_collision = checkCollisions(colliders,1.7, robot_mesh.model, 1.0);
				//console.log("in_collision=",in_collision)
				updateHitbox(bunny_hitbox,[rel_body,rel_ears,rel_head]);
				camera.update(deltaTime);

                //Draw loop
                
                
                gl.clearColor(0.2, 0.2, 0.2, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                //Repete process for the fbo
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                //gl.viewport(0,0,1,1);
                
                gl.clearColor(1.0, 0.6, 0.6, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                

              //get info about the mirror to generate the matrix for the reflection
              
                reflec = camera.get_reflection_matrix(mirror_norm, mirror_position);
                // draw our scene
				
				//// Bunny ////
                shader_reflection.use();
                obj_mesh.activate(shader_reflection);

                
                var unif = shader_reflection.get_uniforms();
				
                view = camera.get_view_matrix();
                //here i guess i should make a function of camera to have the view for
                //the reflection

                gl.uniformMatrix4fv(unif['model'], false, obj_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, obj_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                //gl.uniformMatrix4fv(u_itM, false, itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);
                
                gl.uniform3fv(u_view_dir, camera.get_position());
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);

                obj_mesh.draw();

                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                obj_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				
		
			//// Refraction ////
               shader_refraction.use();
                refract_mesh.activate(shader_refraction);

                var unif = shader_refraction.get_uniforms();
				
                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, refract_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, refract_mesh.model);
                itM = glMatrix.mat4.transpose(itM, itM);
                //gl.uniformMatrix4fv(u_itM, false, itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);
                
                gl.uniform3fv(u_view_dir, camera.get_position());
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);

                refract_mesh.draw();
				

             //// Planets  ////  
                shader_planet.use();
				
				//// Planet 1 ////
                pl_mesh.activate(shader_planet);

                var unif = shader_planet.get_uniforms();

                // Planet Motion 
				
				
				if (in_collision.includes(pl_mesh.model) 
				&& prev_in_collision.includes(pl_mesh.model)== false
				){
					theta1 = -theta1
				}
				
                satellite_rot(pl_mesh.model,theta1, glMatrix.vec3.fromValues(0.0,1.0,0.0),
                                  light_pos,glMatrix.vec3.fromValues(0.0,0.0,0.0),
                                  glMatrix.vec3.fromValues(1.0,1.0,1.0))

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, pl_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                //send the light pos
                gl.uniform3fv(u_light_pos, light_pos);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, pl_mesh.model);
                itM = glMatrix.mat4.transpose(itM,itM);
                //gl.uniformMatrix4fv(u_itM_p,false,itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_planet);
                gl.uniform1i(u_tex_moon,0);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, bump_map);
                gl.uniform1i(u_bump_map,1);

                pl_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                pl_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                /*gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                pl_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);*/
				
				//// Planet 2 ////
               // pl_mesh2.activate(shader_planet);

                // Planet Motion 
                if (in_collision.includes(pl_mesh2.model) 
				&& prev_in_collision.includes(pl_mesh2.model)== false){
					theta2 = -theta2
				}
                satellite_rot(pl_mesh2.model,theta2, glMatrix.vec3.fromValues(-1.0,1.0,0.0),
                                  light_pos,glMatrix.vec3.fromValues(0.0,0.0,0.0),
                                  glMatrix.vec3.fromValues(1.0,1.0,1.0))
				
                gl.uniformMatrix4fv(unif['model'], false, pl_mesh2.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, pl_mesh2.model);
                itM = glMatrix.mat4.transpose(itM,itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);
				
				// Don't need to activate once it is activated
                /*gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_planet);
                gl.uniform1i(u_tex_moon,0);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, bump_map);
                gl.uniform1i(u_bump_map,1);
*/
                pl_mesh2.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                pl_mesh2.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                
				
				
				//// Robot ////
				robot_mesh.activate(shader_planet);
				if(in_collision.includes(robot_mesh.model)){
					glMatrix.mat4.translate(robot_mesh.model, robot_mesh.model, glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
          glMatrix.mat4.translate(part_mesh.model, part_mesh.model, glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
          fire = true;
          start_fire = deltaTime;
				};

				//console.log(dist);
        gl.uniformMatrix4fv(unif['view'], false, view);

				gl.uniformMatrix4fv(unif['model'], false, robot_mesh.model);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, robot_mesh.model);
                itM = glMatrix.mat4.transpose(itM,itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);
                

                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, tex_robot);
                gl.uniform1i(u_tex_moon,2);

                gl.activeTexture(gl.TEXTURE3);
                gl.bindTexture(gl.TEXTURE_2D, bump_map_robot);
                gl.uniform1i(u_bump_map,3);
				
				        robot_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                robot_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);


            


            //// Sun ////
                shader_sun.use();
                sun_mesh.activate(shader_sun);

                var unif = shader_sun.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, sun_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                //send the light pos
                gl.uniform3fv(u_light_pos_sun, light_pos);
                var itM = glMatrix.mat4.create();
                itM = glMatrix.mat4.invert(itM, sun_mesh.model);
                itM = glMatrix.mat4.transpose(itM,itM);
                gl.uniformMatrix4fv(unif['itmodel'],false,itM);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_sun);
                gl.uniform1i(u_tex_sun,0);

                sun_mesh.draw();

                //// draw in other buffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                sun_mesh.draw();
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                
            //// Particle ////
              if (fire === true && deltaTime-start_fire < 0.9){
                //update position of all particle
                var new_part = 100;
                var part_added = 0;
                for (i in particle_list){
                  var part_bool = particle_list[i].update_part(part_added, new_part);
                  if (part_bool){
                    part_added = part_added + 1;
                  }
                }
                //draw the particle
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                shader_particle.use();
                var unif = shader_particle.get_uniforms();
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                gl.uniformMatrix4fv(unif['view'], false, view);
                part_mesh.activate(shader_particle);
                for (i in particle_list){   
                  if(particle_list[i].life > 0.0){
                    var model_part = glMatrix.mat4.create()
                    
                    model_part = glMatrix.mat4.translate(model_part,part_mesh.model,particle_list[i].position);
                    model_part = glMatrix.mat4.rotate(model_part, model_part, 1.5,particle_list[i].orientation);
                    model_part = glMatrix.mat4.scale(model_part,model_part,glMatrix.vec3.fromValues(particle_list[i].size*10,particle_list[i].size*10,particle_list[i].size*10));
                    gl.uniformMatrix4fv(unif['model'], false, model_part);

                    gl.uniform4fv(u_color, particle_list[i].color);
                    gl.uniformMatrix4fv(unif['view'], false, view);
                    part_mesh.draw();

                    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                    gl.uniformMatrix4fv(unif['view'], false, reflec);
                    part_mesh.draw()
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                  }
                }
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
              }
              else if (fire === true){
                fire = false;
              } 
              

              
              
              //// Mirror ////
              //draw the cube map for the mirror:
              gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.depthFunc(gl.LEQUAL);

                shader_cubemap.use();
                cube_mesh.activate(shader_cubemap);

                var unif = shader_cubemap.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, reflec);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                
                // Activate the texture for the cube
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);
                camera.show_view_html(camMatElem, camera.get_view_matrix());
                cube_mesh.draw();

                // set back the depth function for next frame
                gl.depthFunc(gl.LESS);
              gl.bindFramebuffer(gl.FRAMEBUFFER,null);

              //draw the mirror in the canvas
            shader_mirror.use()
              mirror_mesh.activate(shader_mirror);

              const u_n = gl.getUniformLocation(shader_mirror.program,"n");

              var unif = shader_mirror.get_uniforms();

              view = camera.get_view_matrix();
              gl.uniformMatrix4fv(unif['model'], false, mirror_mesh.model);
              gl.uniformMatrix4fv(unif['view'], false, view);
              gl.uniformMatrix4fv(unif['proj'], false, projection);
              var itM = glMatrix.mat4.create();
              itM = glMatrix.mat4.invert(itM, mirror_mesh.model);
              itM = glMatrix.mat4.transpose(itM,itM);
              gl.uniformMatrix4fv(unif['itmodel'],false,itM);

              gl.uniform3fv(u_n,mirror_norm);
              

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, textureColorebuffer);
              gl.uniform1i(u_tex_mirror,0);

              mirror_mesh.draw();


              //// CubeMap ////

                //*    // uncomment only one slash "/" to comment the cubemap ;)
                // We draw the cubemap ONLY at the end!
                gl.depthFunc(gl.LEQUAL);

                // 7) Write the code to draw the scene
                //    Don't forget to send all elements you need in the shaders!
                shader_cubemap.use();
                cube_mesh.activate(shader_cubemap);

                var unif = shader_cubemap.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);
                
                // Activate the texture for the cube
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texCube);
                gl.uniform1i(u_cubemap, 0);
                camera.show_view_html(camMatElem, camera.get_view_matrix());
                cube_mesh.draw();

                // set back the depth function for next frame
                gl.depthFunc(gl.LESS);
                //*/
				prev_in_collision = in_collision;
                fps(time);
                window.requestAnimationFrame(animate); // While(True) loop!
            }

            var prev = 0
            const fpsElem = document.querySelector("#fps");

            function fps(now) {
                now *= 0.001;
                const deltaTime = now - prev;
                prev = now;
                const fps = 1 / deltaTime;
                fpsElem.textContent = 'FPS: ' + fps.toFixed(1);
                return fps;
            }

            animate(0);
        }

        main();
    </script>
</body>

</html>
